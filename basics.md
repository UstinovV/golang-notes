1. Структура проекта
2. Сервер как структура
  * Ресурсы и зависимости
  * Обработчики, middleware
3. Запуск, остановка сервера 
  * обработка сигналов системы
  * работа с контекстом

<h4>Структура проекта</h4>
Основные идеи подчерпнуты из этой [статьи](https://tutorialedge.net/golang/go-project-structure-best-practices/)

Мы будем рассматривать два типа архитектуры как приемлемые:

**Плоская архитектура**
Подходит для маленьких проектов

**Standart project layout**
Для средних и крупных проектов - неофицально принятая в сообществе [архитектура](https://github.com/golang-standards/project-layout)

---

<h4>Сервер как структура</h4>
Самая идея как отсылка к стандартной библиотеке `http.Server`

**Экземпляр сервера:** 
Создаём сервер как отдельный тип(структуру) в которую включаем все зависимости. 

Таким образом мы сможем избежать глобальных переменных, что является плохой практикой
```golang
type server struct {
  db     *Database
  logger *Logger
  router *Router
}
```

**Ресурсы и зависимости**
Наш сервер может использовать внешние ресурсы такие как роутеры, логгеры, инстансы БД и т.д


**Обработчики, middleware** 
Обработчики(handlers) в данном случае являются методами структуры. 

Позволяет обеспечить обработчикам доступ к зависимостям включённым в структуру сервера 
```golang
func (s *server) handleSomething() http.HandlerFunc { ... }
```

В качестве обработчиков лучше использовать не просто функции которые которые реализуют интерфейс `http.Handler`, 
например `func handleAction(w http.ResponseWriter, r *http.Request)`,
а функции которые возвращают такой обработчик, например:
```golang
func (s *server) handleSomething(responseFormat string) http.HandlerFunc {
    //do something
    result := doSomething()
    return func(w http.ResponseWriter, r *http.Request) {
      fmt.Fprintf(w, format, result)
    }
}
```
Это позволит:
* реализовать механизм middlware, т.к. функции могут вкладываться друг в друга, это позволит к примеру проверять авторизацию, включать дополнительную бизнес логику непосредственно перед выполнением функции-обработчика и т.п, результат работы преварительного когда так же можно использовать в функции-обаботчике. В данном примере это `doSomething()`
* если в обработчике требуются дополнительные параметры, которые будут уникальны только для этого обработчика и которые мы не хотим включать в качестве зависимостей в структуру сервера, мы можем передать их в качестве аргумента в функцию обёртки (`responseFormat`)

---

**Запуск, остановка сервиса**

* Сервис запускается в отдельной горутине. Коммуникация сервиса с основной горутиной осуществляется посредством канала с ошибками

```golang
//main.go
```

```golang
//app.go
```

* Не забываем обрабатывать системные сигналы

```golang
  interrupt := make(chan os.Signal, 1)
	signal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM)
  s := <-interrupt
	fmt.Printf("Received a signal: %s \n", s.String())
```

* Не забываем освобождать ресурсы после остановки сервиса. Этого можно добиться посредством общего Context'a и/или в функции остановки
  
```golang
```

**Востановление после паники**
Важно! Допускать паники не стоит. Однако если есть места где возможно её возникновение - необходимо правильно восстановить работу сервиса.

---

Полезные ссылки
- [Пример архитектуры go-сервиса](https://github.com/rtbpanda/go-application-template)
- [Production-ready сервис на Go](https://github.com/PetStores/go-simple/tree/base), [Видео с пояснением](https://youtu.be/yxE5zxTOeUI?t=1822)
- [Как я пишу сервисы спустя 8 лет](https://pace.dev/blog/2018/05/09/how-I-write-http-services-after-eight-years.html) - статья с полезными заметками по написанию go-сервисов
- [Golang tutorial](https://tutorialedge.net/golang/) - туториал с большим количеством рецептов и примерами кода 

TODO
* линтеры
* тестирование
* профилирование